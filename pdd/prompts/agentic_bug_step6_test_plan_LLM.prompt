<pdd-reason>Guides LLM to design observable-behavior test plans during pdd bug step 6.</pdd-reason>

% You are an expert software engineer investigating a bug report. Your task is to design a test plan that will detect this bug.

% Context

You are working on step 6 of 11 in an agentic bug investigation workflow. Previous steps have identified the root cause of the issue.

% Inputs

- GitHub Issue URL: {issue_url}
- Repository: {repo_owner}/{repo_name}
- Issue Number: {issue_number}

% Issue Content
<issue_content>
{issue_content}
</issue_content>

% Previous Steps Output
<step1_output>
{step1_output}
</step1_output>

<step2_output>
{step2_output}
</step2_output>

<step3_output>
{step3_output}
</step3_output>

<step4_output>
{step4_output}
</step4_output>

<step5_output>
{step5_output}
</step5_output>

<step5_5_output>
{step5_5_output}
</step5_5_output>

% Your Task

1. **Review existing tests**
   - Find existing test files for the affected module
   - Understand the testing patterns used in this project
   - Identify gaps in current test coverage

2. **Design the test strategy**
   - What specific behavior needs to be tested?
   - What are the inputs that trigger the bug?
   - What is the expected vs actual output?
   - Are there related edge cases to cover?

3. **Enumerate ALL affected channels**
   The bug may manifest through multiple independent channels. Identify and test every one:
   - **Output bugs**: Don't just test one output method. Check stdout, stderr, Python `logging`, Rich Console, `click.echo`, `print()`, and `warnings` — whichever ones the codebase uses. A fix that silences Rich panels but leaves logger INFO lines leaking is incomplete.
   - **Data flow bugs**: Don't just test one entry point. Check every path where data enters the affected system — API endpoints, CLI commands, function calls, file imports.
   - **State bugs**: Don't just test one state mutation. Check every place where the affected state is read or written.
   - **Configuration bugs**: Don't just test one config source. Check env vars, config files, CLI flags, defaults, and their interaction.
   For each channel, plan at least one test that verifies the bug is fixed through that specific pathway.

4. **Plan test location**
   - Which test file should contain the new test?
   - Should it be added to an existing file or create a new one?
   - Follow the project's testing conventions

5. **Define test cases**
   - Primary test: reproduces the exact bug (always required)
   - Edge cases: related scenarios that should also work (use your judgement)
   - Regression prevention: ensure the fix doesn't break other behavior (use your judgement)

% Output

After completing your analysis, use `gh issue comment` to post your findings to issue #{issue_number}:

```
gh issue comment {issue_number} --repo {repo_owner}/{repo_name} --body "..."
```

Your comment should follow this format:

```markdown
## Step 6: Test Plan

### Existing Test Coverage
- **Test file:** `tests/test_module.py`
- **Current coverage:** [Brief description of what's tested]
- **Gap:** [What's not covered that should be]

### Proposed Tests

#### Test 1: [Name describing the bug scenario]
- **Input:** [The triggering condition]
- **Expected:** [Correct behavior]
- **Actual (before fix):** [Bug behavior]

#### Test 2: [Related edge case]
- **Input:** [Edge case condition]
- **Expected:** [Correct behavior]

### Test Location
- **File:** `tests/test_module.py` (append) or `tests/test_module_bug_123.py` (new)
- **Framework:** [pytest/unittest/etc.]

### Notes
[Any special setup, fixtures, or considerations]

---
*Proceeding to Step 7: Generate Test*
```

% Important

- Tests should be specific enough to catch this exact bug
- Tests should not be so brittle they break with valid changes
- **Coverage check**: Before finalizing, re-read the issue description and list every distinct symptom mentioned. Your test plan must cover ALL of them — not just the easiest ones. If the issue lists 4 symptoms and your plan only covers 2, go back and add tests for the missing ones.
- **Channel check**: For each symptom, ask "through which channel does this manifest?" (stdout, stderr, logging, Rich, click.echo, warnings, return value, side effect, state change). If a symptom can leak through multiple channels, test each one. The fix is only complete when ALL channels are covered — a fix that suppresses Rich output but leaves Python logging untouched is a partial fix, and the tests should catch that.
- Always post your findings as a GitHub comment before completing
